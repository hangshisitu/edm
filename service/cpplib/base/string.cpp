/*        Copyright (c) 2004 Richinfo Inc, All Rights Reserved      */
/*        Author: wengshanjin                    Date: 2010-08      */

#include "base/string.h"

RFC_NAMESPACE_BEGIN

const stdstring StringFunc::g_strSpaceString = " \t\r\n\f\v";
const stdstring StringFunc::g_strCRLF = "\r\n";
const stdstring StringFunc::g_strEmptyString;
const stdwstring StringFunc::g_wstrEmptyWideString;

const stdstring StringFunc::g_strUpperHexChar = "0123456789ABCDEF";
const stdstring StringFunc::g_strLowerHexChar = "0123456789abcdef";

const unsigned char StringFunc::g_UpcaseCharsetMap[] = 
{
	0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
	0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
	0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
	0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
	0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,
	0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,
	0x60,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,
	0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x7b,0x7c,0x7d,0x7e,0x7f,
	0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,
	0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,
	0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,
	0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,
	0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,
	0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,
	0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,
	0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff
};

const unsigned char StringFunc::g_LowcaseCharsetMap[] = 
{
	0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
	0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
	0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
	0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
	0x40,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
	0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x5b,0x5c,0x5d,0x5e,0x5f,
	0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
	0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,
	0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,
	0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,
	0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,
	0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,
	0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,
	0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,
	0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,
	0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff
};

bool StringFunc::decodeNumberToDec(const char * pEncodeNumber, size_t nLen, rfc_uint_32 & nDecimalResult)
{
	const char * pEnd = pEncodeNumber + nLen;
	rfc_uint_32 nBase = 10;
	if ( pEncodeNumber < pEnd && *pEncodeNumber == '0' )
	{
		++pEncodeNumber;
		nBase = 8;
	}
	else if ( nLen > 2 && StringFunc::strnCasecmp(pEncodeNumber, "0x", 2) == 0 )
	{
		nBase = 16;
		pEncodeNumber += 2;
	}

	nDecimalResult = 0;
	for ( ; pEncodeNumber < pEnd; ++pEncodeNumber )
	{
		
		rfc_uint_32 nDecNumber = static_cast<rfc_uint_32>( convertHexNumberToDec(*pEncodeNumber) );
		if ( nDecNumber >= nBase )
			return false;

		nDecimalResult *= nBase;
		nDecimalResult += nDecNumber;
	} // for ( ; pEncodeNumber < pEnd; ++pEncodeNumber )
	return true;
}

rfc_int_64 StringFunc::convertSizeUnitToByte(const char * pStr, size_t nLen)
{
	rfc_int_64 nResult(0), nTemp = 0;
	const char * tpEnd = pStr + (nLen == std::basic_string<char>::npos ? StringFunc::length(pStr) : nLen );
	for ( const char * tp = skipSign(pStr, tpEnd); tp < tpEnd; ++tp )
	{
		char ch = *tp;
		if ( ::isdigit(ch) )				// '0' - '9'
		{
			nTemp *= 10;
			nTemp += ch - char('0');
		}
		else
		{
			switch ( ch )
			{
			case 'T':
			case 't':
				nTemp *= 1024;
			case 'G':
			case 'g':
				nTemp *= 1024;
			case 'M':
			case 'm':
				nTemp *= 1024;
			case 'K':
			case 'k':
				nTemp *= 1024;
			default:
			//case 'B':
			//case 'b':
				break;
			} // switch ( ch )

			nResult += nTemp;
			nTemp = 0;
		} // if ( ::isdigit(ch) )				// '0' - '9'
	} // for ( const char * tp = skipSign(pStr, tpEnd); tp < tpEnd; ++tp )
	nResult += nTemp;
	return getSignedResult(nResult, pStr, tpEnd);
}

rfc_int_64 StringFunc::convertPeriodUnitToMilliSecond(const char * pStr, size_t nLen)
{
	rfc_int_64 nResult(0), nTemp = 0;
	const char * tpEnd = pStr + (nLen == std::basic_string<char>::npos ? StringFunc::length(pStr) : nLen );
	for ( const char * tp = skipSign(pStr, tpEnd); tp < tpEnd; ++tp )
	{
		char ch = *tp;
		if ( ::isdigit(ch) )				// '0' - '9'
		{
			nTemp *= 10;
			nTemp += ch - char('0');
		}
		else
		{
			switch ( ch )
			{
			case 'D':			// ÃÏ
			case 'd':
				nTemp *= 24;
			case 'H':			//  ±
			case 'h':
				nTemp *= 60;
			case 'M':
			case 'm':
				if ( (tp + 1 >= tpEnd) || ( *(tp + 1) != 's' && *(tp + 1) != 'S') )	// ∑÷
					nTemp *= 60;
				else			// ∫¡√Î
				{
					++tp;
					break;
				}
			case 'S':			// √Î
			case 's':
			default:
				nTemp *= 1000;
				break;
			} // switch ( ch )

			nResult += nTemp;
			nTemp = 0;
		} // if ( ::isdigit(ch) )				// '0' - '9'
	} // for ( const char * tp = skipSign(pStr, tpEnd); tp < tpEnd; ++tp )
	nResult += nTemp * 1000;
	return getSignedResult(nResult, pStr, tpEnd);
}

void StringFunc::appendCRLF(stdstring & strLine)
{
	if ( (!strLine.empty()) && *strLine.rbegin() != '\n' )
		strLine += g_strCRLF;
}

void StringFunc::removeCRLF(stdstring & strLine)
{
	size_t nCRLFPos = strLine.find_first_of(g_strCRLF);
	if( nCRLFPos != stdstring::npos )
		strLine.erase(nCRLFPos);
}

//////////////////////////////////////////////////////////////////////////

void SimpleString::clear()
{
	if ( m_pStorage != NULL )
	{
		delete []m_pStorage;
		m_pStorage = NULL;
	}
}

void SimpleString::reset(const SimpleString::typeChar * pSrc)
{
	if ( m_pStorage == pSrc )
		return;

	clear();
	size_t nLen = (pSrc == NULL) ? 0 : StringFunc::length(pSrc);
	if ( nLen > 0 )
	{
		m_pStorage = new typeChar [nLen + 1];
		StringFunc::strnCpy(m_pStorage, pSrc, nLen);
	}
}

const SimpleString::typeChar * SimpleString::get(void) const
{
	if ( m_pStorage == NULL )
		return StringFunc::g_strEmptyString.c_str();
	return m_pStorage;
}

//////////////////////////////////////////////////////////////////////////

FindSubString & FindSubString::operator = (const FindSubString & s)
{
	if ( this == &s )
		return *this;

	clear();
	if ( s.m_nKeySize > 0 )
	{
		m_nKeySize = s.m_nKeySize;
		m_pKeyBuffer = new typeChar[m_nKeySize];
		memcpy( m_pKeyBuffer, s.m_pKeyBuffer, m_nKeySize * sizeof(typeChar) );
		m_pIndex = new size_t[256 * sizeof(typeChar)];
		memcpy( m_pIndex, s.m_pIndex, 256 * sizeof(typeChar) * sizeof(size_t) );
	} //if ( s.m_nKeySize > 0 )
	return *this;
}

void FindSubString::compileKeyWord(const typeChar * pKey, size_t nKeySize)
{
	clear();
	if ( nKeySize > 0 )
	{
		m_nKeySize = nKeySize;
		m_pKeyBuffer = new typeChar[m_nKeySize];
		memcpy( m_pKeyBuffer, pKey, m_nKeySize * sizeof(typeChar) );
		
		size_t i = 0, nIndexCount = 256 * sizeof(typeChar);
		m_pIndex = new size_t[nIndexCount];
		for ( i = 0; i < nIndexCount; ++i )
			m_pIndex[i] = m_nKeySize + 1;
		for ( i = 0; i < m_nKeySize; ++i )
		{
			typeUnsignedChar ch = static_cast<typeUnsignedChar>( pKey[i] );
			m_pIndex[ch] = m_nKeySize - i;
			typeUnsignedChar chLower = static_cast<typeUnsignedChar>( StringFunc::tolower(pKey[i]) );
			m_pIndex[chLower] = m_nKeySize - i;
		}
	} //if ( nKeySize > 0 )
}

void FindSubString::clear(void)
{
	m_nKeySize = 0;
	delete []m_pKeyBuffer;
	m_pKeyBuffer = NULL;
	delete []m_pIndex;
	m_pIndex = NULL;
}

size_t FindSubString::findCaseSensitive(const typeChar * pText, size_t nTextLen) const
{
	if ( nTextLen < m_nKeySize )
		return stdstring::npos;
	if ( m_nKeySize == 0 )
		return 0;

	for ( size_t i = 0; i + m_nKeySize <= nTextLen; )
	{
		if ( memcmp(pText + i, m_pKeyBuffer, m_nKeySize * sizeof(typeChar)) == 0 )
			return i;
		typeUnsignedChar ch = static_cast<typeUnsignedChar>( pText[i + m_nKeySize] );
		i += m_pIndex[ch];
	} //for ( size_t i = 0; i + m_nKeySize <= nTextLen; )
	return stdstring::npos;
}

bool FindSubString::matchCaseSensitive(const typeChar * pText, size_t nTextLen) const
{
	return ( findCaseSensitive(pText, nTextLen) != stdstring::npos );
}

size_t FindSubString::findIgnoreCase(const typeChar * pText, size_t nTextLen) const
{
	if ( nTextLen < m_nKeySize )
		return stdstring::npos;
	if ( m_nKeySize == 0 )
		return 0;

	for ( size_t i = 0; i + m_nKeySize <= nTextLen; )
	{
		if ( StringFunc::strCasecmp(pText + i, m_nKeySize, m_pKeyBuffer, m_nKeySize) == 0 )
			return i;
		typeUnsignedChar ch = static_cast<typeUnsignedChar>( StringFunc::tolower(pText[i + m_nKeySize]) );
		i += m_pIndex[ch];
	} //for ( size_t i = 0; i + m_nKeySize <= nTextLen; )
	return stdstring::npos;
}

bool FindSubString::matchIgnoreCase(const typeChar * pText, size_t nTextLen) const
{
	return ( findIgnoreCase(pText, nTextLen) != stdstring::npos );
}

void StringScaner::scanString(const char * p, size_t n)
{
	if ( p == NULL || n == 0 )
		return;
	const char * pEnd = p + n;
	beforeScan(p, pEnd);
	for ( ; p < pEnd; ++p )
	{
		if ( !onScan(p) )
			break;
	}
	afterScan(p, pEnd);
}

RFC_NAMESPACE_END
